<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link href="./python.css" rel="stylesheet" />
    <title>About Python</title>
  </head>
  <body>
    <header>
      <img src="../../img/logo.png" alt="Logo" id="Logo" />
      <div class="menu">
        <a href="../../mainPage/main.html">home</a>
        <a href="../../rakingPage/rankingPage.html">ranking</a>
      </div>
      <div id="searchContainer">
        <input type="text" id="searchBar" placeholder="search anything you want" />
        <img src="../../img/search.png" alt="검색창" />
      </div>
    </header>
    <div id="container">
      <div id="leftBar">
        <img src="../../img/Python.png" id="PImg" />
        <div id="contents">
          <span>목차</span>
          <hr />
          <ul>
            <li><a href="#1">개요</a></li>
            <li><a href="#2">디자인 철학</a></li>
            <li><a href="#3">장점</a></li>
            <li><a href="#4">단점</a></li>
          </ul>
        </div>
      </div>
      <div id="content">
        <h1 id="1">개요</h1>
        <hr />
        파이썬은 1991년에 발표된 인터프리터 방식의 프로그래밍 언어이다. 파이썬의 강력한 라이브러리와 풍부한 생태계를 통해, 데이터를 수집하고 분석하며 시각화하기
        용이하다. 데이터 분석 분야에서 파이썬의 사용이 널리 퍼진 이유 중 하나는, 다른 프로그래밍 언어에 비해 직관적이기 때문에 비교적 쉽고 간편하게 사용할 수
        있기 때문이다. 파이썬은 웹 프레임워크와 같은 라이브러리와 함께 사용될 경우, 데이터를 수집하고 처리한 후 결과를 웹 애플리케이션으로 표시하는 것도
        가능하다.<br />
        <h1 id="2">디자인 철학</h1>
        <hr />
        '가장 아름다운 하나의 답이 존재한다'를 기본으로 하고 있다.
        <p>
          예를 들어 팩토리얼 함수는 다음과 같이 간결히 나타낼 수 있다. 이 예시에서는 프로그래밍 초보자들을 헷갈리게 하는 3항 연산자(Ternary operator)도 쉽게
          읽혀 Python의 "실행할 수 있는 의사 코드"라는 별명을 다시금 느낄 수 있다.
        </p>
        <p>
          이것은 남이 작성한 코드를 내가 읽고 이해해야 하는 경우 아주 절실히 느낄 수 있다. PEP 20에서 제시된 Python 기본 철학(The Zen of Python)에 자세히
          나열되어 있다.
        </p>
        <li>아름다운 것이 추한 것보다 낫다. (Beautiful is better than ugly.)</li>
        <li>명시적인 것이 암시적인 것보다 낫다. (Explicit is better than implicit.)</li>
        <li>간결한 것이 복합적인 것보다 낫다. (Simple is better than complex.)</li>
        <li>복합적인 것이 복잡한 것보다 낫다. (Complex is better than complicated.)</li>
        <li>수평적인 것이 내포된 것보다 낫다. (Flat is better than nested.)</li>
        <li>여유로운 것이 밀집한 것보다 낫다. (Sparse is better than dense.)</li>
        <li>가독성은 중요하다. (Readability counts.)</li>
        <li>특별한 경우들은 규칙을 어길 정도로 특별하지 않다. (Special cases aren't special enough to break the rules.)</li>
        <li>허나 실용성은 순수성을 이긴다. (Although practicality beats purity.)</li>
        <li>오류는 절대로 조용히 지나가지 않는다. (Errors should never pass silently.)</li>
        <li>명시적으로 오류를 감추려는 의도가 아니라면. (Unless explicitly silenced.)</li>
        <li>모호함을 대할 때, 이를 추측하려는 유혹을 거부하라. (In the face of ambiguity, refuse the temptation to guess.)</li>
        <li>명확한, 그리고 가급적이면 유일한 하나의 방법은 항상 존재한다. (There should be one-- and preferably only one --obvious way to do it.)</li>
        <li>비록 그 방법이 처음에는 명확해 보이지 않을지라도. (Although that way may not be obvious at first unless you're Dutch.)</li>
        <li>지금 행동에 옮기는 것이 아예 안 하는 것보다는 낫다. (Now is better than never.)</li>
        <li>비록 아예 안 하는 것이 지금 *당장* 하는 것보다 나을 때도 많지만. (Although never is often better than *right* now.)</li>
        <li>구현 결과를 설명하기 쉽지 않다면, 그것은 나쁜 아이디어이다. (If the implementation is hard to explain, it's a bad idea.)</li>
        <li>구현 결과를 설명하기 쉽다면, 그것은 좋은 아이디어일지도 모른다. (If the implementation is easy to explain, it may be a good idea.)</li>
        <li>네임스페이스를 사용하는 것은 완전 좋은 생각이다! (Namespaces are one honking great idea -- let's do more of those!)</li>

        따라서 다른 언어들의 코딩 스타일은 각자의 취향에 맞게 발산 진화하는 반면, Python은 위의 철학들을 만족시키는 하나의 스타일로 수렴 진화하는 성향이 있다.
        이런 성향은 다른 언어에는 없는 Python스러움(pythonic)이라는 독특한 개념을 낳게 되었는데, 복잡하지 않으면서 의미가 명확하고, 코드의 축약보다 뚜렷하게
        보이는 흐름을 중시하는 Python의 철학을 지칭하는 개념이다.<br />
        <h1 id="3">장점</h1>
        <hr />
        Python의 아이덴티티. 높은 생산성은 그 무엇과도 비교할 수 없는 Python만의 특징이다. 전 세계의 모든 프로그래밍 언어 중에서 Python 정도의 낮은 난이도를
        가지면서, 오만가지 분야에서 생산된 훌륭한 패키지들을 통해 범용성까지 갖춘 프로그래밍 언어는 찾기 힘들다. Python으로 만든 프로그램을 같은 객체 지향
        프로그래밍 언어인 Java나 C++로 만드려는 순간 숨이 턱 막힐 정도. 인터프리터 언어이면서 우수한 자료형과 다양한 모듈 등을 제공해 개발 기간이 단축되는 것이
        특징. Python이 막 유행을 타기 시작했을 때에는 'C언어로 2년 동안 완성하지 못한 프로젝트를 Python으로 한 달 만에 해냈다'는 극적인 경험담이 커뮤니티에
        돌았을 정도다. 당장 Python의 집합 자료형 같은 경우 C언어로 구현하려고 하면 머리가 아파 온다. 아니 객체지향 언어랑 절차지향 언어랑 비교하니까 그렇지..
        C언어와의 접착성도 좋기 때문에, 일단 Python으로 빨리 구현하고, 남은 시간에 속도에 병목이 되는 부분을 C++로 전환하는 전략을 내세우고 있다. 버전이
        올라가면서 Python 자체도 그리 느리지 않게 되었다. 심지어 어셈블리어 같은 저수준 언어(Low level)도 Python에서 호출할 수 있다. Python은 어지간한 다른
        프로그래밍 언어들을 지원하는 호환성 덕분에 응용할 곳이 무궁무진하다.실행 속도만 빼고 파이썬 출시 당시인 1991년에 개발 속도가 빠르다고 했는데 Traceback도
        한몫한다. 이전에 유명와 인터프리터언어였던 perl 은 스택트레이스를 보여주지 않았기 때문이다. 반면 파이썬은 코드를 실수로 잘못 짠 곳이 있다면, 어떤 스택을
        통해 어떤 어떤 파일의 어떤 줄에서 어떤 함수에서 어떤 종류의 문제가 발생했는지 자세하게 알려준다. 스택을 전부 보여주기 때문에 초보자에게는 당황스러울 수
        있지만, 디버깅을 하다 보면 정말 편리하다. 아래는 오류(Exception) 발생 시의 터미널 출력 예시다. 파이썬 이후에 나온 인터프리터 언어들은 스택트레이스와
        오류 줄을 표시한다. Python 가지고 스프레드시트나 데이터베이스까지 만드는 괴수들도 있다. Python으로 SQL을 구현하는 건 불가능하다는 소리가 있었지만 우리의
        Nerd들은 해내고 말았다. 2013년 Python으로 관리하는 DB 개념이 잡힌 이후 수많은 피드백 끝에 2015년 도전 성공. 심지어 2017년 프랑스의 중견기업에서 Python
        DB 프로젝트를 보더니 정말로 회사의 DB를 Python으로 관리하는 사업을 벌려서 DB화되지 못하고 저장되던 회사 내부의 파일형 자료들과 기존의 DB에 저장된 자료를
        접합시키는 사업까지 했다 한다. 빠른 아이디어 구현이 생명인 연구소에서 각광을 받고 있고, 인스타그램, 유튜브, reddit 등이 Python을 주로 쓰고 있다고 알려져
        있으며, 외국의 구인 사이트에도 Python을 할 줄 아는 사람에 대한 수요가 많다. 컴퓨터 관련이 아닌 이공계 전반에서 많이 쓰이는 MATLAB은 오픈소스가 아니라는
        점이 최근 추세와 맞지 않아 입지가 좁아지고 있다.[23] CG 업계에서도 사실상 표준으로 사용되는 스크립트 언어이다. MEL, MAXScript 등 프로그램별로 자체
        스크립트 언어들이 난립하고 있었는데, 현재는 Python 스크립팅을 주력으로 밀고 있다. 또한 공대 졸업작품으로도 자주 쓰이는 프로그래밍 언어이기도 하다. 동적
        타입 언어(Dynamically typed language)라는 점이 큰 프로젝트에서는 단점으로 작용하여 자료 구조 설계나 디버깅이 어렵다는 지적도 있다. 다만 "정적 타입 vs.
        동적 타입" 논쟁은 서로의 장단점이 있다. 일례로 OCaml 같은 강력한 타입 인터페이스(Hindley-Milner, System F 등)를 가진 경우, 모든 타입 에러(!)를 컴파일
        타임에 잡아낼 수 있는 반면에, 모든 버그가 타입 에러는 아니기 때문에 여전히 테스트 및 디버깅 과정은 필요하다, 반면에 동적 언어는 빠른 구현의 이점이
        있지만 타입 에러가 많이 나는 특징이 있다. 한마디로, 컴파일 언어의 경우에는 컴파일 시간에 오류를 잡지만 동적언어는 놓치게 된다는 소리. Python으로
        파서(Parser)를 많이 작성해 봤다면, 십중팔구 읽은 숫자를 string으로 저장했다가 나중에 연산을 했더니 연산이 불가능하다면서 에러가 나거나 이상한 결과가
        나온 경험이 있을 것이다. Python 3.5부터는 타입 힌트를 이용해서 변수가 가질 수 있는 타입을 지정할 수 있게 되어 IDE 가 타입힌트를 해석해 타입오류를 쉽게
        도움받을 수 있게 되었다. 그렇지만 실행중 체크를 하지는 않기때문에 여전히 주의 해야한다
        <br />
        <h1 id="4">단점</h1>
        <hr />
        우선 기본적으로 가장 아쉬운 점은 속도이다. 한 논문에 따르면, CLBG에서 제시한 10개의 벤치마킹을 돌려본 결과 Python은 C에 비해 71.90배의 시간, 2.80배의
        메모리, 75.88배의 에너지를 더 소모한다고 한다.[30] 느린 속도를 보완하기 위해서 보통 여러 가지 방법이 동원된다. 기본적으로는 math나 random과 같은
        Python의 내장 모듈을 사용해서 멀티쓰레딩이나 멀티프로세싱을 구현한다. 다만 Python은 글로벌 락 인터프리터(GLI) 문제로 애초에 멀티프로세싱에 효율적인
        타입이 아니다. 즉 멀티 프로세싱을 해도 별로 나아지지 않을 수 있다는 얘기. 혹자는 Scipy나 Numpy와 같은 모듈의 고속 계산 함수를 별도로 개발해
        쓰기도(Vectorize) 한다. 더 나아가서는 속도가 빠른 C와 같은 언어를 래핑(Wrapping)하여 작성하기도 한다. 전문적으로 개발할 때는 외부 패키지에 의존하지 않고
        직접 작성한 코드에서 고속화를 하기 위해 자연스럽게 더 높은 난이도의 언어를 혼합해서 개발하게 된다. 이 경우 Python은 논리적인 부분을 담당하고, 래핑된
        다른 언어는 코어를 담당하게 된다. 사실 전문적인 개발회사라면 이게 일반적이다. 대표적인 예시로 Numba나 Cython같은 제3자 솔루션을 이용하기도 하며, 흔히
        인공지능 용도로 사용된다고 오해받는 Python TensorFlow 는 사실 C++ 이다. Python 을 이용해 TensorFlow 를 '호출도' 할 수 있을뿐이다, TensorFlow 의 로직을
        수정 및 커스텀 하기 위해선 반드시 C++ 코드에 손을 대야 한다. 이처럼 Python은 사실 다른 언어에 비해 많이 느리기 때문에 프로그래밍 대회에서 실행시간 제한
        때문에 어려움을 겪기도 한다. 시스템을 건드리거나 반복 연산이 많은 것은 하기 어렵지만 python numpy 처럼 따로 모듈을 지원하기 때문에 크게 걱정할 필요는
        없다. 하지만 python numpy을 사용해도 느린 건 느리다. [31] 결국 Python은 첫 교육용 언어로는 몇달 좋으나 어느정도 튜토리얼을 벗어나려면 C언어를 이용해야
        한다는 이야기. 아예 C언어부터 시작하는 것이 낫다는 관점도 존재한다. GIL(Global Interpreter Lock)은 Python의 성능 저하를 얘기할 때 빼놓을 수 없다.
        Python은 멀티쓰레딩을 지원하기 위하여 GIL을 도입하여 사용하게 되었다. 따라서, python 쓰레드 10개를 만들어도 실제 Pthread/윈도우 쓰레드가 10개가
        만들어지긴 하는데, GIL 때문에 개중 동시에 하나밖에 안 돌아가는 기이한 구조를 갖고 있다. 물론, 내부적으로 IO작업이 있을 시 바로 다른 쓰레드로 문맥 교환을
        해주고, 바이트 코트를 100번 실행한 다음에는 인터프리터 차원에서 다른 쓰레드로 교체해 주므로 동시 작업 비슷한 효과가 난다. 이것은 구현이 매우 쉬워지고
        빠른 개발을 할 수 있다는 장점이 있으나, 다중 코어 CPU가 보편화된 2006년 이후에는 다중 코어를 제대로 활용하지 못하는 구조적인 문제 때문에 HW를 이용하지
        못한다는 평가를 받게 되었다. 만일 특정 프로그램에 순진하게 CPU 코어를 2개 이상 동원하려고 할 경우, 뮤텍스(MutEx), 즉 한 쓰레드에 여러 개의 CPU가 연산을
        행하여 내부 정보를 오염 시키는 것을 방지하는 역할을 맡는 GIL이 병목 현상을 일으켜 코어 하나를 쓸 때보다 오히려 성능이 크게 저하된다는 것. 구글 내부에서
        이미 가루가 되도록 까인 부분이다. 다만 GIL은 멀티프로세싱에서는 해당되지 않는 이야기다. 멀티프로세싱 모듈은 메모리를 완전히 분리해서 사용하기 때문이다.
        일반적으로 기계어로 컴파일하여 사용하는 C, C++보다는 당연히 느리고, Lua, PHP. JavaScript, LISP 계열 언어 등 동적 언어들을 전체를 주욱 놓고 비교해 봐도
        속도가 빠른 편은 아니다. Python처럼 가상 머신 위에서 실행되는 Java, JavaScript 등의 언어들의 경우, 속도 문제를 극복하기 위해서 JIT 컴파일러를 도입했다.
        Python의 사실상의 표준 구현체인 CPython은 JIT 컴파일을 도입하지 않았고, JIT 컴파일을 도입한 별도의 구현체인 PyPy가 등장했다. 통계 분야 등 특정
        분야에서는 R과 같이 그 분야에 특화된 언어를 사용하는 것이 더 편리할 수도 있다. 더불어, 예전의 Python에는 CPU-bound한 쓰레드가 I/O-bound한 쓰레드와 함께
        돌아갈 때, I/O-bound한 쓰레드가 실행되어야 할 상황에서도 context switch가 제대로 이루어지지 않는 문제가 있었다. 이 때문에 CPU-bound 쓰레드가 GIL을
        지나치게 오래 점유하게 되면서 I/O 반응 속도가 느려지고, 다른 쓰레드는 GIL을 획득하려고 계속 시도하느라 CPU 시간을 낭비하게 되었다. 이에 대해 Python
        전문가인 David Beazley가 2009년에 Mindblowing Python GIL이라는 강연에서 지적하였다.[32] 이후 Antoine Pitrou라는 개발자가 GIL을 뜯어고쳐 해당 문제를
        해결하였고, Python 3.2부터는 새로운 GIL이 적용되어서 성능이 어느 정도 개선되었다. 단, CPU 부하가 큰 작업을 돌리는 것이 아니면 GIL을 체감하기는 생각보다
        쉽지 않다. 다중 쓰레딩으로 CPU의 여러 코어를 최대한 이용하고 싶은 경우에는 GIL가 굉장히 아쉬운 이슈지만, CPU를 별로 쓰지 않거나 I/O가 주가 되는 작업은
        유의미한 성능 차이가 없다. 게다가 어설프게 코어 몇 개 깔짝깔짝 이용해서 계산하는 것보다는 그냥 C언어로 모듈을 짜서 붙이는 게 더 빠르다. 즉, python에서
        CPU를 많이 먹는 부분은 C 모듈을 짜서 붙이거나, 이미 C 모듈로 짜여있는 라이브러리를 사용하거나(Numpy, Scipy 등), 필요하다면 multiprocessing 모듈을
        이용하여 멀티코어를 활용하는 편. 그 이상의 CPU 부하가 큰 작업은 처음부터 C, C++로 짜는 게 맞다. 하지만 대규모 연산의 멀티코어의 성능 향상을 보기 위한 것
        말고도, I/O가 주가 되는 작업(즉, 여러 개의 I/O 이벤트를 기다리는 것)을 위해서 멀티쓰레드를 사용하는 경우가 많고,[33] 이런 경우에도 복잡한 동기화를 해야
        하는 멀티쓰레딩을 사용하는 건 낭비이다. 왜냐하면 디버깅도 힘들 뿐만 아니라, 실제로는 I/O를 위해 기다리는 시간이 실제 I/O가 발생했을 때 필요한 처리
        작업을 수행하는 시간보다 월등히 긴 경우가 많아 여러 개의 쓰레드를 관리하기 위한 자원만 낭비하는 꼴이기 때문이다. 따라서 Go나 Erlang 같은 프로그래밍
        언어들은 코루틴이란 개념을 도입해[34] 이러한 "event multiplexing"을 싱글쓰레드로도 구현할 수 있게 하고 있다. 특히 멀티쓰레딩할 때 필요한 각종 동기화
        문제 없이 마치 싱글 쓰레드 코드를 짜는 것과 거의 동일한 방식으로 코드를 작성할 수 있으면서도 그러한 코드들이 "동시에" 동작하는 것처럼 실행해 주므로
        프로그래머 입장에서 매우 편하다. 실제로는 각 이벤트에 필요한 처리를 하고 다음 이벤트가 발생하기 전까지 비는 시간에 다른 이벤트를 처리하는 코드를
        실행시켜 주는 방식으로, 시분할과 비슷하지만 문맥 전환이 프로그래머가 작성한 코드에서 명시적으로 다음 이벤트를 기다려야 할 필요가 있을 때 협력적으로
        발생한다는 차이점이 있다. C 같은 언어에서 이러한 코루틴 지원이 잘 안 되는 이유는, 언어적 차원에서 함수 중간에 실행을 멈추고 다른 함수를 실행할 수 있게
        해줘야 하는데 쓰레드 별로 stack이 1개밖에 없는 구조에서는 구현이 어렵고 하나의 함수로 짜야 할 내용을 여러 개의 callback 함수로 쪼개면 코드가
        지저분해진다는 단점이 크기 때문이다. 이런 callback 형태를 사용하는 게 초기 Node.js 개발 환경이다. 위에서 기술한 Stackless Python에서 코루틴을 먼저
        지원할 수 있었던 것도 이런 배경이 있다. 그나마 C++은 C++20에서 지원하기 시작했다. 다행히 Python은 (stackless가 아니더라도) yield 키워드를 통해 함수 실행
        흐름을 제어할 수 있다. Python 3.4 버전부터는 표준 라이브러리의 각종 파일 입출력, subprocess, socket 통신 등의 기능들을 모두 코루틴화해 주는 asyncio
        패키지가 기본 탑재되었다. Python 3.5 부터는 C#를 본딴 async 함수 선언자와 await 키워드가 포함되어 asyncio 라이브러리에 의존할 수밖에 없던 코루틴 기능을
        다른 서드파티 라이브러리도 보다 쉽게 지원할 수 있도록 바뀌고, 코루틴 내부에서의 예외 처리 과정이 개선되었다큰 요새는 특정 경우를 제외하면 자동으로 GIL을
        on/off시켜 주는 것으로 보인다. 이렇게 속도를 빠르게 하려고 별별 방법을 동원한다는 것과 이를 잘 아는 사람이 드물다는 것을 감안하면, Python의 최대 단점은
        기본적으로 속도가 느리다는 것과 이를 개선하기가 어렵다는 것이라고 할 수 있겠다. 이로서 파생된 문제점으로 Python에 입문하는 것은 쉽지만 마스터하긴
        어렵다는 문제점이 발생한다. 이는 프로그래밍 입문만 Python으로 하고 다른 언어를 주력으로 배우고 쓰는 것으로 해결될 수도 있지만,[35] Python은 C 패밀리와
        이질적인 문법으로 인해[36] 다른 프로그래밍 언어를 배우는데 별 도움이 안된다는 새로운 문제가 생긴다. 당연하겠지만 Python 언어 자체를 구현하는 사람들도
        느린 실행 속도가 Python의 최대 단점이라는 사실을 인식하고 있고 이를 개선하기 위해 다양한 방면에서 연구를 진행하고 있다. 후술할 PyPy와 같이 JIT컴파일을
        하는 구현체를 만든 것도 그 결과물 중 하나이며, 최근에는 공식적이자 가장 호환성이 높은 CPython의 속도 또한 개선되고 있다. 2020년 Python 창시자 귀도 반
        로섬은[37] 2021년 Python 회담(Python Language Summit)에서 버전 3.11에서는 속도를 2배 향상시키고, 향후 4년간은 속도를 5배 향상시키는 것이 목표라고
        말했다. 실제로 2022년에 발표된 Python 3.11 버전에서는 상당한 속도 개선이 이루어진 것으로 보인다. 문제는 개선되었다고는 하지만 그래도 다른 프로그래밍
        언어들과 비교하면 여전히 느리다는 것과 속도가 개선되는데 한계가 있다는 것이다. 이 때문에 미래에도 속도 개선이 지속적으로 이루어져야 쓸만한 속도가 나올
        것으로 보인다.
      </div>
    </div>
  </body>
</html>
